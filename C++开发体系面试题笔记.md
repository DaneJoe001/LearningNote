##### 数据类型转换

###### 分析下列代码输出的结果：

``` c
char c = 250;
unsigned char d;
char f;
d = c + 249;
f = c + 249;
printf("d=%d\n", d);
printf("d=%u\n", d);
printf("f=%d\n", f);
printf("f=%u\n", f);
```

``` markdown
题目分析:
249对应二进制
1111 1001(单纯作为数值进行计算)
250对应二进制
1111 1010(无论有无符号，数串都为补码)
250本身是正数，但将1111 1010赋值给有符号char型后，最高位变为符号位
此时补码1111 1010
对应反码1111 1001
对应原码1000 0110
对应值为-6
（这一点不重要）
重要的是1111 1010这一串数值会完整赋给c,作为补码参与运算

    C+249
C    1111 1010
249  1111 1001
   1 1111 0011

由于char型只有八位
故d和f数串都只会截取
1111 0011

由低类型向高类型转换，值不会改变
无符号char型，对应的值为243
1111 0011（全部为数值位）
用int型表示为
0000 0000 0000 0000 0000 0000 1111 0011
由于243为正数，原码补码反码一致
在计算机存储为补码形式
0000 0000 0000 0000 0000 0000 1111 0011
无论是以有符号型int还是无符号型int输出
补码与原码一致，故都为243

由低类型向高类型转换，值不会改变
有符号char型，对应的值为-13
1111 0011（此时以补码形式存储）
1111 0010（对应反码）
1000 1101（对应原码）
用int型表示为
1000 0000 0000 0000 0000 0000 0000 1101
在计算机存储为补码形式
1111 1111 1111 1111 1111 1111 1111 0010（对应反码）
1111 1111 1111 1111 1111 1111 1111 0011（此时以补码形式存储）

对应的原码扩展0，转换为补码，由于输出有符号，故将该补码转换成对应原码输出
故输出-13
对应的原码扩展0，转换为补码，由于输出无符号，故将该补码当作正数原码输出
故输出4294967283

实际上可以说在输出前，char型都被扩展到了整型！
只是在输出的时候，区分有无符号，对值进行不同的解释！
最后得到不同的最终结果！
```

![image-20240726111108534](E:\我的文件\Markdown文件\MD图像附件\image-20240726111108534.png)

![image-20240805091448447](E:\我的文件\Markdown文件\MD图像附件\image-20240805091448447.png)

![image-20240805091504076](E:\我的文件\Markdown文件\MD图像附件\image-20240805091504076.png)

![image-20240805091529831](E:\我的文件\Markdown文件\MD图像附件\image-20240805091529831.png)

![image-20240805091540252](E:\我的文件\Markdown文件\MD图像附件\image-20240805091540252.png)

![image-20240805091556194](E:\我的文件\Markdown文件\MD图像附件\image-20240805091556194.png)

![image-20240805091756296](E:\我的文件\Markdown文件\MD图像附件\image-20240805091756296.png)

![image-20240805091808373](E:\我的文件\Markdown文件\MD图像附件\image-20240805091808373.png)

![image-20240805091830990](E:\我的文件\Markdown文件\MD图像附件\image-20240805091830990.png)

![image-20240829111623822](E:\我的文件\Markdown文件\MD图像附件\image-20240829111623822.png)

![image-20240830125216018](E:\我的文件\Markdown文件\MD图像附件\image-20240830125216018.png)
