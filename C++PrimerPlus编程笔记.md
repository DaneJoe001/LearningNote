# C++ Primer Plus

## 第一章 预备知识
### 1.1 C++简史
#### 1.2.1 C语言
#### 1.2.2 C语言编程原理
#### 1.2.3 面向对象编程
#### 1.2.4 C++和泛型编程
#### 1.2.5 C++的起源
### 1.3 可移植性和标准
#### 1.3.1 C++的发展
#### 1.3.2 本书遵循的C++标准
### 1.4 程序创建的技巧
#### 1.4.1 创建源代码文件

##### C++命名规范

> 在C++（以及大多数编程语言）中，命名规范是一个非常重要的方面，它不仅关乎代码的可读性，还直接影响到代码的维护性和团队协作效率。下面将详细介绍一些C++中关于命名规范的常见约定和最佳实践。

###### 1. 命名风格

C++社区普遍接受几种不同的命名风格，其中最著名的有：

- **CamelCase（驼峰命名法）**：
  - **小驼峰命名法（lowerCamelCase）**：第一个单词首字母小写，后续单词首字母大写。常用于变量名、函数名等。
    ```cpp
    int myVariable;
    void myFunction();
    ```
  - **大驼峰命名法（UpperCamelCase）**：所有单词首字母都大写，也称为PascalCase。常用于类名、结构体名、枚举类型等。
    ```cpp
    class MyClass {};
    struct MyStruct {};
    enum MyEnum {};
    ```

- **下划线分隔（snake_case）**：单词之间用下划线分隔，常用于常量名、宏定义等。
    ```cpp
    const int MAX_VALUE = 100;
    #define PI 3.14159
    ```

###### 2. 命名约定

- **变量命名**：
  - 使用有意义的名称，避免使用单个字符（除了循环变量如`i`, `j`, `k`等）。
  - 使用小驼峰命名法。
  - 对于布尔变量，可以使用`is`, `has`, `can`等前缀来表明其性质，如`isVisible`, `hasData`。

- **函数命名**：
  - 遵循小驼峰命名法。
  - 动词或动词短语描述函数的行为。
  - 如果函数返回一个布尔值，则函数名可以是一个问题，如`isValid()`, `isEmpty()`。

- **类命名**：
  - 使用大驼峰命名法（PascalCase）。
  - 类名应该反映其职责或用途。

- **常量命名**：
  - 通常使用全大写字母和下划线分隔（SNAKE_CASE）。
  - 对于`const`变量，如果其命名足够清晰地表明其用途和值不会改变，也可以采用小驼峰命名法，但保持一致性很重要。

- **命名空间命名**：
  - 命名空间使用大驼峰命名法（PascalCase），有助于避免命名冲突。

- **宏定义命名**：
  - 通常也使用全大写字母和下划线分隔（SNAKE_CASE），以区分于其他类型的标识符。

###### 3. 避免使用的命名

- 避免使用C++的保留关键字作为变量名、函数名等。
- 避免使用过于通用的名称，如`temp`, `data`等，除非在非常有限的局部作用域内。
- 避免使用数字或特殊字符作为标识符的开头（尽管C++允许这样做，但会降低可读性）。

###### 4. 团队和项目的命名规范

最重要的是，在项目或团队内部要保持命名规范的一致性。可以通过编写代码规范文档来明确命名规则，并在代码审查过程中强制执行这些规则。这有助于提高代码质量，促进团队成员之间的协作。

#### 1.4.2 编译和链接

## 第二章 开始学习C++
### 2.1 进入C++
#### 2.1.1 main()函数
#### 2.1.2 C++注释
#### 2.1.3 C++预处理器和iostream文件

##### 2.1.3.1 预处理器

> C/C++语言中的预处理指令是编译器在编译之前对源代码进行处理的指令。这些指令以`#`字符开头，告诉预处理器（preprocessor）对源代码进行特定的操作。预处理指令不包含在最终的编译结果中，但它们对编译过程有重要影响。下面是一些常见的C/C++预处理指令：

###### 1. **#define**：
   `#define`指令用于定义宏。它可以定义无参数的宏（简单的文本替换）或带参数的宏（类似于函数调用的文本替换）。宏定义在预处理阶段被替换到源代码中，使得代码更加简洁或易于维护。

   ```c
   #define PI 3.14159
   #define MAX(a, b) ((a) > (b) ? (a) : (b))
   ```

###### 2. **#include**：
   `#include`指令用于包含（或插入）另一个文件的内容到当前文件中。这通常用于包含标准库头文件或用户自定义的头文件，以便在多个源文件中共享声明、宏定义等。

   ```c
   #include <stdio.h> // 包含标准输入输出库
   #include "myheader.h" // 包含用户自定义的头文件
   ```

###### 3. **#ifdef, #ifndef, #endif, #else, #elif**：
   这些指令用于条件编译。它们允许根据是否定义了某个宏来决定是否包含某段代码。这在跨平台编程或根据不同的编译选项启用/禁用特定功能时非常有用。

   ```c
   #ifdef DEBUG
   printf("Debug mode is on.\n");
   #endif
   
   #ifndef SOME_FEATURE
   #define SOME_FEATURE 1
   // 实现一些功能
   #endif
   ```

###### 4. **#undef**：
   `#undef`指令用于取消宏定义。一旦宏被`#undef`取消，预处理器将不再替换该宏名。

   ```c
   #define MY_MACRO 1
   // ... 使用MY_MACRO ...
   #undef MY_MACRO
   // 之后MY_MACRO将不再被替换
   ```

###### 5. **#line**：
   `#line`指令允许改变预处理器报告的当前行号和文件名。这通常用于生成的文件中，以便调试时能够更准确地指向原始源代码的位置。

   ```c
   #line 100 "newfile.c"
   // 之后的错误和警告将报告为来自newfile.c的第100行
   ```

###### 6. **#pragma**：
   `#pragma`指令是编译器特定的预处理指令，用于提供编译器特定的指令。不同的编译器可能支持不同的`#pragma`指令，因此它的使用是高度依赖于编译器的。

   ```c
   #pragma once // 这是一个常见的非标准但广泛支持的指令，用于防止头文件被重复包含
   ```

###### 7. **#error** 和 **#warning**：
   `#error`和`#warning`指令分别用于生成编译时错误和警告。这可以用于在编译时检查某些条件是否满足，如果不满足则生成错误或警告信息。

   ```c
   #ifndef SOME_REQUIRED_MACRO
   #error "SOME_REQUIRED_MACRO is not defined"
   #endif
   ```

> 这些预处理指令是C/C++语言灵活性和强大功能的一部分，它们允许程序员在编译之前对源代码进行复杂的操作，从而生成更加高效、可移植和易于维护的代码。



#### 2.1.4 头文件名

#### 2.1.5 名称空间
#### 2.1.6 使用cout进行C++输出
#### 2.1.7 C++源代码的格式化
### 2.2 C++语句
#### 2.2.1 声明语句和变量
#### 2.2.2 赋值语句
#### 2.2.3 cout的新花样
### 2.3 其他C++语句
#### 2.3.1 使用cin
#### 2.3.2 使用cout进行拼接
#### 2.3.3 类简介
### 2.4 函数
#### 2.4.1 使用有返回值的函数
#### 2.4.2 函数变体
#### 2.4.3 用户定义的函数
#### 2.4.4 用户定义的有返回值的函数
#### 2.4.5 在多函数程序中使用using编译指令

## 第三章 处理数据
### 3.1 简单变量
### 3.2 const限定符
### 3.3 浮点数
### 3.4 C++算数运算符

## 第四章 复合类型
### 4.1 数组
### 4.2 字符串
### 4.3 string类简介
### 4.4 结构简介
### 4.5 共用体
### 4.6 枚举
### 4.7 指针和自由存储空间
### 4.8 指针、数组和指针算数
### 4.9 类型组合
### 4.10 数组的替代品

#### vector容器

> `vector` 是 C++ 标准模板库（STL）中的一个非常重要的序列容器，它提供了对一段连续存储空间的动态数组的功能。`vector` 能够存储任意类型的对象，包括自定义类型，并且能够自动管理存储空间的分配和释放。与数组相比，`vector` 的主要优势在于它能够根据需要动态地增长和缩小存储空间，从而提供了更大的灵活性。

##### 基本特性

- **动态数组**：`vector` 内部实现通常是一个动态分配的数组，但对外提供了类似数组的操作接口，如使用下标访问元素。
- **自动内存管理**：当 `vector` 的大小增加时，如果需要更多空间来存储元素，它会自动重新分配一个更大的连续内存空间，并将现有元素复制到新的空间中。同样，当元素被删除且空间不再需要时，它也会释放多余的内存。
- **随机访问**：由于 `vector` 内部是连续存储的，因此支持通过下标进行快速的随机访问。
- **迭代器**：`vector` 提供了迭代器（iterator），允许使用范围基循环（如 `for` 循环）遍历容器中的元素。
- **容量与大小**：`vector` 有两个重要的属性——大小和容量。大小（`size()`）是容器中当前存储的元素数量，而容量（`capacity()`）是容器在不进行内存重新分配的情况下能够存储的元素的最大数量。

##### 常用操作

- **插入元素**：可以使用 `push_back()` 在 `vector` 的末尾插入一个新元素，也可以使用 `insert()` 在指定位置插入一个或多个元素。
- **删除元素**：可以使用 `pop_back()` 删除 `vector` 的最后一个元素，或者使用 `erase()` 删除一个或多个元素。
- **访问元素**：可以通过下标操作符 `[]` 访问元素（不检查越界），或者使用 `at()` 成员函数（会检查越界并抛出异常）来访问元素。
- **遍历元素**：可以使用迭代器或者范围基循环（C++11及以后）遍历 `vector` 中的元素。
- **大小和容量**：使用 `size()` 获取 `vector` 的大小，使用 `capacity()` 获取其容量。如果需要，可以使用 `reserve()` 预留足够的空间以避免不必要的内存重新分配。
- **清空**：使用 `clear()` 移除 `vector` 中的所有元素，但保留内存空间。如果需要释放内存，可以接着使用 `shrink_to_fit()`（C++11及以后）尝试减少容量以匹配当前大小。

##### 示例代码

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec;

    // 向vector中添加元素
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    // 遍历vector
    for (int i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    // 使用迭代器遍历
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // 插入和删除元素
    vec.insert(vec.begin(), 0); // 在开头插入0
    vec.erase(vec.begin() + 2); // 删除第三个元素

    // 访问元素
    std::cout << "The second element is: " << vec[1] << std::endl;

    return 0;
}
```

这个示例展示了 `vector` 的一些基本操作，包括添加元素、遍历元素、插入和删除元素以及访问元素。

## 第五章 循环和关系表达式
### 5.1 for循环
### 5.2 while循环
### 5.3 do while 循环
### 5.4 基于范围的for循环（C++11）
### 5.5 循环和文本输入
### 5.6 嵌套循环和二维数组

## 第六章 分支语句和逻辑运算符
### 6.1 if语句
### 6.2 逻辑表达式
### 6.3 字符函数库cctype
### 6.4 ?:运算符
### 6.5 switch语句
### 6.6 break和continue语句
### 6.7 读取数字的循环
### 6.8 简单文件输入/输出

## 第七章 函数——C++的编程模块
### 7.1 复习函数的基本知识
### 7.2 函数参数和按值传递
### 7.3 函数和数组
### 7.4 函数和二维数组
### 7.5 函数和C-风格字符串
### 7.6 函数和结构
### 7.7 函数和string对象
### 7.8 函数与array对象
### 7.9 递归
### 7.10 函数指针

## 第八章 函数探幽
### 8.1 C++内联函数
### 8.2 引用变量
### 8.3 默认参数

<返回值类型><函数名>(<参数列表>)const；

const表明此函数不会修改对象状态,这是一个好习惯，特别是在设计类的接口时。

### 8.4 函数重载

函数重载不能根据返回值类型进行重载

### 8.5 函数模板

## 第九章 内存模型和名称空间
### 9.1 单独编译
### 9.2 存储持续性、作用域和链接性
### 9.3 名称空间

避免在头文件中使用`using namespace std;`：虽然在这个简单的示例中为了简化而使用了它，但在实际项目中，最好避免在头文件中使用`using namespace std;`，因为它可能会导致命名冲突。相反，你应该在需要的地方显式地使用`std::`前缀。

## 第十章 对象和类
### 10.1 过程性编程和面向对象编程
### 10.2 抽象和类
### 10.3 类的构造函数和析构函数

#### * **构造函数格式**：

> <类名>(参数列表):类成员(函数参数),类成员(函数参数){}
>
> 当声明与实现分开时，在函数定义中不需要指定与声明中相同的默认参数。

``` c++
//用参数列表中传入的参数对类成员进行初始化
//当使用无参的构造函数时，可以用值初始化类成员
//默认构造函数：无参的构造函数
```

* 类成员函数名不能与类成员变量名冲突

1. **数组大小作为非类型模板参数**：在C++中，你不能直接在类定义中使用外部定义的`const int`作为数组的大小，除非它是编译时常量表达式（比如`constexpr`或者枚举值）。但是，对于普通的`const int`，这通常不是编译时常量表达式。因此，你不能这样做。你可以改用`constexpr`，但更常见的做法是使用`std::array`或`std::string`。
2. **构造函数中的数组初始化**：在C++中，你不能在构造函数初始化列表中直接初始化数组（包括字符数组）。数组需要在构造函数体内通过循环或其他方式逐个元素地设置。但是，如果你使用`std::array`或`std::string`，你可以在初始化列表中直接初始化它们。

### 10.4 this指针
### 10.5 对象数组
### 10.6 类作用域
### 10.7 抽象数据类型

## 第十一章 使用类
### 11.1 运算符重载
### 11.2 计算时间：一个运算符重载示例
### 11.3 友元
### 11.4 重载运算符：作为成员函数还是非成员函数
### 11.5 再谈重载：一个矢量类
### 11.6 类的自动转换和强制类型转换

## 第十二章 类和动态内存分配
### 12.1 动态内存和类
### 12.2 改进后的新String类
### 12.3 在构造函数中使用new时应注意的事项
### 12.4 有关返回对象的说明
### 12.5 使用指向对象的指针
### 12.6 复习各种技术
### 12.7 队列模拟

## 第十三章 类继承
### 13.1 一个简单的基类
### 13.2 继承：is-a关系
### 13.3 多态公有继承
### 13.4 静态联编和动态联编
### 13.5 访问控制：protected
### 13.6 抽象基类
### 13.7 继承和动态内存分配
### 13.8 类设计回顾

## 第十四章 C++中的代码重用
### 14.1 包含对象成员的类
### 14.2 私有继承
### 14.3 多重继承
### 14.4 类模板

## 第十五章 友元、异常和其他
### 15.1 友元
### 15.2 嵌套类
### 15.3 异常
### 15.4 RTTI
### 15.5 类型转换运算符

## 第十六章 string类和标准模板库
### 16.1 string类
### 16.2 智能指针模板类
### 16.3 标准模板库

#### `<vector>`容器

>`<vector>` 是 C++ 标准模板库（STL）中的一个非常重要和常用的容器，它提供了动态数组的功能。`<vector>` 容器可以存储一系列的元素，这些元素在内存中连续存储，并且可以动态地增长或缩小。以下是一些 `<vector>` 的常用方法：

#### `<stack>`栈

> `<stack>` 容器适配器在 C++ 标准模板库（STL）中提供了对栈（后进先出，LIFO）数据结构的支持。虽然 `<stack>` 的操作相对简单，但它提供了几个基本且常用的操作，以满足栈的基本功能需求。以下是 `<stack>` 的常用操作：

##### 1. 构造函数

- `stack()`: 创建一个空的栈。
- `stack(const stack& other)`: 创建一个栈的副本，复制 `other` 栈中的所有元素。

##### 2. 元素插入

- `void push(const T& value)`: 在栈顶插入一个新元素 `value`。这是向栈中添加元素的唯一方式。

##### 3. 元素删除

- `void pop()`: 删除栈顶的元素，但不返回该元素的值。这是从栈中移除元素的唯一方式。

##### 4. 访问栈顶元素

- `T& top()`: 返回栈顶元素的引用。注意，这不会从栈中移除元素，只是提供了访问它的方式。
- `const T& top() const`: 这是 `top()` 函数的常量版本，用于在栈是常量时访问栈顶元素。

##### 5. 栈的状态检查

- `bool empty() const`: 检查栈是否为空。如果栈为空，则返回 `true`；否则返回 `false`。
- `size_t size() const`: 返回栈中元素的数量。注意，`size()` 返回的类型通常是 `size_t`，这是一个无符号整数类型，用于表示大小。

##### 示例代码

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;

    // 检查栈是否为空
    if (myStack.empty()) {
        std::cout << "Stack is empty." << std::endl;
    }

    // 向栈中添加元素
    myStack.push(10);
    myStack.push(20);

    // 访问栈顶元素
    std::cout << "Top element is: " << myStack.top() << std::endl;

    // 删除栈顶元素
    myStack.pop();

    // 再次访问栈顶元素
    std::cout << "New top element is: " << myStack.top() << std::endl;

    // 获取栈的大小
    std::cout << "Stack size: " << myStack.size() << std::endl;

    return 0;
}
```

> 在这个示例中，我们首先创建了一个空的 `std::stack<int>` 对象 `myStack`。然后，我们向栈中添加了两个整数元素（10 和 20）。接着，我们访问并输出了栈顶元素（20），然后删除了它。之后，我们再次访问并输出了新的栈顶元素（10），并获取了栈的大小（1）。

> 注意，`<stack>` 容器适配器不提供直接访问栈中除栈顶之外元素的方法，也不支持在栈的任意位置插入或删除元素。这些限制是栈数据结构本身的特性所决定的。

##### 1. 构造函数

   - `vector<T> v;`：创建一个空的 `vector`。
   - `vector<T> v(n);`：创建一个有 `n` 个元素的 `vector`，所有元素都被初始化为 `T()`（即默认构造函数）。
   - `vector<T> v(n, val);`：创建一个有 `n` 个元素的 `vector`，所有元素都被初始化为 `val`。
   - `vector<T> v(beg, end);`：创建一个 `vector`，其内容是 `[beg, end)` 范围内的元素的一个副本，其中 `beg` 和 `end` 是迭代器。
   - `vector<T> v(const vector<T>& other);`：复制构造函数，创建一个与 `other` 相同内容的 `vector`。

##### 2. 赋值

   - `v = other;`：将 `v` 的内容替换为 `other` 的内容。

##### 3. 大小操作

   - `v.size()`：返回 `v` 中元素的数量。
   - `v.empty()`：如果 `v` 为空，则返回 `true`。
   - `v.resize(n);`：将 `v` 的大小改为 `n`，如果 `n` 大于当前大小，则新元素被初始化为 `T()`。
   - `v.resize(n, val);`：将 `v` 的大小改为 `n`，如果 `n` 大于当前大小，则新元素被初始化为 `val`。

##### 4. 元素访问

   - `v[n]`：返回 `v` 中位置为 `n` 的元素的引用（注意：不检查索引是否越界）。
   - `v.at(n)`：返回 `v` 中位置为 `n` 的元素的引用，如果 `n` 越界，则抛出 `std::out_of_range` 异常。
   - `v.front()`：返回 `v` 中第一个元素的引用。
   - `v.back()`：返回 `v` 中最后一个元素的引用。

##### 5. 修改操作

   - `v.push_back(val)`：在 `v` 的末尾添加一个元素 `val`。
   - `v.pop_back()`：移除 `v` 的最后一个元素。
   - `v.insert(pos, val)`：在 `v` 中迭代器 `pos` 指向的位置之前插入一个新元素 `val`，并返回指向新元素的迭代器。
   - `v.insert(pos, n, val)`：在 `v` 中迭代器 `pos` 指向的位置之前插入 `n` 个值为 `val` 的新元素。
   - `v.insert(pos, beg, end)`：在 `v` 中迭代器 `pos` 指向的位置之前插入一个范围 `[beg, end)` 内的元素副本。
   - `v.erase(pos)`：移除 `v` 中迭代器 `pos` 指向的元素，并返回指向下一个元素的迭代器。
   - `v.erase(beg, end)`：移除 `v` 中范围 `[beg, end)` 内的元素。

##### 6. 迭代器

   - `v.begin()`：返回指向 `v` 中第一个元素的迭代器。
   - `v.end()`：返回指向 `v` 中最后一个元素之后位置的迭代器（这是一个“尾后迭代器”，不指向任何元素）。
   - `v.rbegin()` 和 `v.rend()`：分别返回指向 `v` 中最后一个元素和第一个元素之前位置的反向迭代器。

##### 7. 容量

   - `v.capacity()`：返回 `v` 在不重新分配内存的情况下能够存储的元素数量。
   - `v.shrink_to_fit()`（C++11及以后）：请求移除未使用的容量（即减小 `v` 的容量以匹配其大小）。注意，这是一个非强制性请求，实现可能忽略它。

> 这些是 `<vector>` 的一些基本和常用的方法。`<vector>` 因其灵活性和易用性而非常受欢迎，是 C++ 中最常用的容器之一。

### 16.4 泛型编程
### 16.5 函数对象
### 16.6 算法
### 16.7 其他库

#### `<array> `头文件

> `std::array` 是 C++11 引入的一个固定大小的数组容器，它提供了比原生数组更多的功能和安全性，同时保持了与原生数组类似的性能。`std::array` 是模板类，定义在头文件 `<array>` 中。

##### 主要特点

1. **固定大小**：与原生数组一样，`std::array` 的大小在编译时就已确定，不能动态改变。
2. **容器接口**：`std::array` 提供了标准库容器的接口，比如 `begin()`, `end()`, `size()`, `empty()` 等成员函数，这使得它在使用上更加灵活和方便。
3. **随机访问**：由于 `std::array` 的大小是固定的，并且存储在连续的内存中，因此它支持随机访问，即可以在常数时间内访问任意元素。
4. **类型安全**：使用 `std::array` 可以避免一些原生数组常见的类型错误，比如数组越界等。
5. **初始化列表**：`std::array` 支持使用初始化列表进行初始化，这使得代码更加简洁。

##### 示例

```cpp
#include <iostream>  
#include <array>  
int main() {  
    // 声明并初始化一个 std::array  
    std::array<int, 5> arr = {1, 2, 3, 4, 5};  
    // 使用范围for遍历  
    for (int elem : arr) {  
        std::cout << elem << ' ';  
    }  
    std::cout << '\n';  
    // 使用迭代器遍历  
    for (std::array<int, 5>::iterator it = arr.begin(); it != arr.end(); ++it) {  
        std::cout << *it << ' ';  
    }  
    std::cout << '\n';  
    // 访问特定元素  
    std::cout << "The first element is: " << arr[0] << '\n';  
    // 获取数组大小  
    std::cout << "The size of the array is: " << arr.size() << '\n';  
    return 0;  
}
```

##### 注意事项

- 尽管 `std::array` 提供了许多便利，但由于其大小固定，因此在需要动态数组大小的情况下，应该使用 `std::vector`。
- `std::array` 的大小是模板参数，因此它必须是编译时常量。
- `std::array` 支持几乎所有的标准容器操作，但由于其大小固定，一些操作（如 `push_back()`）自然是不支持的。
- `std::array` 的性能与原生数组非常接近，因为它们在内部都是以连续内存的形式存储元素。然而，由于 `std::array` 提供了更多的功能和安全性，因此在许多情况下它是更好的选择。

####  `<cstdlib>` 头文件

##### abs()函数

> 在C++中，`abs()` 函数是一个用于计算整数绝对值的函数。然而，需要注意的是，`abs()` 函数实际上并不直接定义在C++标准库中，而是定义在C标准库 `<cstdlib>`（或C++中的 `<stdlib.h>`，尽管推荐使用C++风格的头文件）中。C++标准库为了与C标准库兼容，也包含了这些函数。
>
> `abs()` 函数只能用于整数类型（如 `int`），并返回其参数的绝对值。如果你需要计算浮点数（如 `float` 或 `double`）的绝对值，你应该使用 `<cmath>`（或C++中的 `<math.h>`，但同样推荐使用C++风格的头文件）库中的 `fabs()`, `fabsf()`, 或 `fabsl()` 函数，分别对应 `double`、`float` 和 `long double` 类型。

###### 使用 `abs()` 函数

下面是一个使用 `abs()` 函数的简单示例：

```cpp
#include <iostream>  
#include <cstdlib> // 包含 abs() 函数  
  
int main() {  
    int number = -5;  
    int absoluteValue = abs(number);  
  
    std::cout << "The absolute value of " << number << " is " << absoluteValue << std::endl;  
  
    return 0;  
}
```

在这个例子中，`abs()` 函数被用来计算整数 `-5` 的绝对值，并打印结果。

###### 注意

- 如果你正在处理浮点数，请使用 `<cmath>` 中的 `fabs()`, `fabsf()`, 或 `fabsl()` 函数。
- 对于更复杂的数值类型（如复数），C++标准库提供了 `<complex>` 头文件，其中包含了计算复数绝对值的函数。
- 考虑到跨平台兼容性，当你处理不同大小的整数时（如 `long`、`long long`），C++标准库并没有直接提供这些类型的 `abs()` 版本。不过，C++17 引入了 `<cmath>` 中的 `std::abs` 模板函数，它可以用于任何数值类型，包括整数和浮点数。对于整数类型，这个模板函数的行为与 `<cstdlib>` 中的 `abs()` 函数类似，但提供了更好的类型支持和灵活性。

###### C++17 示例

```cpp
#include <iostream>  
#include <cmath> // 包含 std::abs 模板函数  
  
int main() {  
    int number = -5;  
    double floatingNumber = -3.14;  
  
    std::cout << "The absolute value of " << number << " is " << std::abs(number) << std::endl;  
    std::cout << "The absolute value of " << floatingNumber << " is " << std::abs(floatingNumber) << std::endl;  
  
    return 0;  
}
```

在这个C++17示例中，`std::abs` 被用于计算整数和浮点数的绝对值。

#### `<limits>`头文件

> 在C++中，`<limits>`头文件提供了对基本数据类型（如整数、浮点数等）的属性和限制的访问，包括它们能表示的最大值、最小值、精度等。以下是一些常用的方法来获取这些最值：

##### 1. 获取整数类型的最大值和最小值

> 对于整数类型（如`int`、`long`、`short`、`unsigned int`等），你可以使用`std::numeric_limits`模板类来获取它们的最大值和最小值。

``` cpp
    #include <iostream>  
    #include <limits>  
    
    int main() {  
        // 获取int的最大值和最小值  
        std::cout << "int的最大值: " << std::numeric_limits<int>::max() << std::endl;  
        std::cout << "int的最小值: " << std::numeric_limits<int>::min() << std::endl;  
    
        // 对于无符号类型，最小值总是0  
        std::cout << "unsigned int的最大值: " << std::numeric_limits<unsigned int>::max() << std::endl;  
        std::cout << "unsigned int的最小值: " << std::numeric_limits<unsigned int>::min() << std::endl; // 总是0  
    
        return 0;  
    }
```

##### 2. 获取浮点类型的最大值、最小值和精度

> 对于浮点类型（如`float`、`double`），`std::numeric_limits`同样适用，并且你还可以获取到它们的精度（epsilon，即两个可表示值之间的最小差异）等信息。

``` cpp
    #include <iostream>  
    #include <limits>  
    
    int main() {  
        // 获取double的最大值和最小值  
        std::cout << "double的最大值: " << std::numeric_limits<double>::max() << std::endl;  
        std::cout << "double的最小值: " << std::numeric_limits<double>::min() << std::endl; // 注意：这是最小的正数  
    
        // 获取double的最小绝对值（即负数的最小值）  
        std::cout << "double的最小绝对值: " << -std::numeric_limits<double>::lowest() << std::endl;  
    
        // 获取double的精度（epsilon）  
        std::cout << "double的精度(epsilon): " << std::numeric_limits<double>::epsilon() << std::endl;  
    
        return 0;  
    }
```

##### 注意事项

> - 对于无符号整数类型，`std::numeric_limits<T>::min()`总是返回0，因为无符号整数没有负数。
- 浮点数的`std::numeric_limits<T>::min()`返回的是该类型能表示的最小**正**值，而`std::numeric_limits<T>::lowest()`返回的是该类型能表示的最小值（对于浮点数来说，这通常是负的）。
- 浮点数的`epsilon`表示的是1与大于1的最小浮点数之间的差，是浮点数精度的一个度量。

> 通过`<limits>`头文件和`std::numeric_limits`模板类，你可以很方便地获取C++中基本数据类型的各种属性和限制。

#### `<cctype>`头文件

> `<cctype>` 是C++标准库中的一个头文件，它继承自C语言中的 `<ctype.h>`，提供了一系列用于字符分类和转换的函数。这些函数在处理字符串、验证输入等方面非常有用。以下是 `<cctype>` 中一些常用的函数及其功能介绍：

##### 字符测试函数

1. **isalnum(int c)**: 如果参数 `c` 是字母或数字（即字母A-Z、a-z或数字0-9），则返回非零值（真）。
2. **isalpha(int c)**: 如果参数 `c` 是字母（A-Z、a-z），则返回非零值（真）。
3. **iscntrl(int c)**: 如果参数 `c` 是控制字符（ASCII码中0到31以及127的字符，通常不可见），则返回非零值（真）。
4. **isdigit(int c)**: 如果参数 `c` 是数字（0-9），则返回非零值（真）。
5. **isgraph(int c)**: 如果参数 `c` 是除空格之外的打印字符（即可以打印的字符，但不是空格），则返回非零值（真）。
6. **islower(int c)**: 如果参数 `c` 是小写字母（a-z），则返回非零值（真）。
7. **isprint(int c)**: 如果参数 `c` 是打印字符（包括空格），则返回非零值（真）。
8. **ispunct(int c)**: 如果参数 `c` 是标点符号，则返回非零值（真）。
9. **isspace(int c)**: 如果参数 `c` 是标准空白字符（如空格、换行符、制表符等），则返回非零值（真）。
10. **isupper(int c)**: 如果参数 `c` 是大写字母（A-Z），则返回非零值（真）。
11. **isxdigit(int c)**: 如果参数 `c` 是十六进制数字（0-9、a-f、A-F），则返回非零值（真）。

##### 字符转换函数

1. **tolower(int c)**: 如果参数 `c` 是大写字母，则返回其小写形式；否则，返回该参数不变。
2. **toupper(int c)**: 如果参数 `c` 是小写字母，则返回其大写形式；否则，返回该参数不变。

##### 注意事项

- 这些函数都接受一个 `int` 类型的参数，但实际上它们只处理该参数的低8位（即ASCII值或Unicode字符的某个表示）。
- 返回值通常为非零值（表示真）或零值（表示假）。在C++中，这些返回值可以直接用于布尔表达式。
- 尽管这些函数通常用于处理 `char` 类型的字符，但它们也可以处理更宽的字符类型（如 `wchar_t`），但需要使用相应的宽字符版本函数（定义在 `<cwctype>` 中）。

##### 示例代码

> 以下是一个简单的示例，展示了如何使用 `<cctype>` 中的一些函数：

```cpp
#include <iostream>
#include <cctype>

int main() {
    char ch = 'A';

    if (isalpha(ch)) {
        std::cout << "'" << ch << "' 是字母。" << std::endl;
    }

    if (isupper(ch)) {
        std::cout << "'" << ch << "' 是大写字母。" << std::endl;
        char lower_ch = tolower(ch);
        std::cout << "'" << ch << "' 的小写形式是 '" << lower_ch << "'。" << std::endl;
    }

    if (isdigit(ch + '0')) { // 将 'A' 转换为 '10'（这里仅为示例，实际上 'A' + '0' 并不等于 '10'）
        std::cout << "'" << (char)(ch + '0') << "' 是数字（但请注意，这里的转换仅为示例）。" << std::endl;
        // 注意：上面的转换只是为了演示如何修改字符并检查，实际上并不合理
    }

    return 0;
}
```

> 请注意，示例中的 `ch + '0'` 转换仅为演示目的，实际上它并不会将 `'A'` 转换为数字字符。正确的数字字符检查应该直接使用 `isdigit` 函数对数字字符（如 `'0'` 到 `'9'`）进行操作。

#### `<fstream>`头文件

> `fstream` 是 C++ 标准库中的一个头文件，它定义了用于文件输入/输出（I/O）的类。这个头文件结合了 `iostream` 和 `fstreambase` 的功能，允许程序以面向对象的方式进行文件的读写操作。`fstream` 提供的类能够处理顺序文件（即文件中的数据按照写入顺序被读取或写入），并且支持二进制模式和文本模式。

##### 主要类

- `ifstream`（input file stream）：用于从文件读取数据。它继承自 `istream` 类。
- `ofstream`（output file stream）：用于向文件写入数据。它继承自 `ostream` 类。
- `fstream`：同时支持读写操作。它继承自 `iostream` 类，结合了 `ifstream` 和 `ofstream` 的功能。

##### 使用方法

> 要使用 `fstream` 头文件中的类，首先需要包含这个头文件：

```cpp
#include <fstream>
```

> 然后，可以创建 `ifstream`、`ofstream` 或 `fstream` 的对象，并使用它们来打开文件、读写数据以及关闭文件。

###### 打开文件

> 所有这三个类都提供了 `open` 成员函数来打开文件。这个函数接受一个字符串参数（文件名），以及一个可选的模式参数（如 `ios::in`、`ios::out`、`ios::app`、`ios::binary` 等）来指定文件的打开方式。

```cpp
ifstream fileIn;
fileIn.open("example.txt", ios::in);

ofstream fileOut;
fileOut.open("output.txt", ios::out | ios::trunc);

fstream fileIO;
fileIO.open("io.txt", ios::in | ios::out | ios::app);
```

###### 读写文件

> 一旦文件被成功打开，就可以使用 `>>`（从文件读取）和 `<<`（向文件写入）操作符，或者成员函数如 `read`、`write`、`getline` 等来进行数据的读写操作。

```cpp
// 使用 ifstream 读取
string line;
while (getline(fileIn, line)) {
    cout << line << endl;
}

// 使用 ofstream 写入
fileOut << "Hello, World!" << endl;

// 使用 fstream 读写
fileIO << "Appending text." << endl;
```

###### 关闭文件

> 完成文件操作后，应该使用 `close` 成员函数来关闭文件。虽然析构函数也会自动关闭文件，但显式关闭文件是一个好习惯，特别是在进行大量文件操作时。

```cpp
fileIn.close();
fileOut.close();
fileIO.close();
```

##### 注意事项

- 在打开文件时，如果文件不存在且使用了 `ios::in` 模式，则 `open` 函数会失败。如果文件不存在且使用了 `ios::out` 或 `ios::out | ios::trunc` 模式，则会创建新文件。
- 使用 `ios::app` 模式时，写入操作会将数据追加到文件末尾，而不是覆盖原有内容。
- `fstream` 允许在打开文件时同时指定 `ios::in` 和 `ios::out` 模式，但这样做时，需要小心处理文件的位置指针，以免在读写操作中产生意外的结果。

`fstream` 提供了灵活且强大的文件操作能力，是 C++ 程序中处理文件不可或缺的一部分。

## 第十七章 输入、输出和文件

### 17.1 C++输入和输出概述
### 17.2 使用cout进行输出
### 17.3 使用cin进入输入

1. **基本读取操作**

   - `operator>>`：重载的提取运算符，用于读取数据并自动跳过空白字符（如空格、制表符、换行符）。

     ```cpp
     int age;
     string name;
     cin >> age >> name; // 依次读取整数和字符串
     ```

2. **getline()**

   - `getline` 是 C++ 中用于读取字符串的一个非常实用的函数，它可以从输入流中读取一行文本直到遇到指定的分隔符，默认的分隔符是换行符（'\n'）。`getline` 有两个重载版本，分别位于 `<string>` 和 `<iostream>` 头文件中，分别用于处理 `std::string` 和字符数组。
	- 处理字符串的函数原型
	```cpp
	std::getline(std::istream& is, std::string& str, char delim = '\n');
	//is：输入流对象，如 `std::cin`。
	//str：存储读取到的字符串的变量。
	//delim：可选参数，指定的分隔符，默认为换行符`\n`。当遇到这个字符时停止读取。
   //getline(cin, stringVar);：从 `cin` 读取一行到字符串 `stringVar` 中。
	```
	  - 字符串示例：
	
   ```cpp
	#include <iostream>
   #include <string>
   int main() {
    	std::string line;
    	std::cout << "请输入一行文本：";
        std::getline(std::cin, line);
        std::cout << "你输入的是：" << line << std::endl;
        return 0;
    }
   ```
   * 处理字符数组的函数原型
    ```cpp
    std::istream& getline(char* s, std::streamsize n, char delim);
    //s：指向字符数组的指针，用来存储读取到的字符串。
    //n：字符数组的大小，确保不会发生缓冲区溢出。
    //delim：同上，指定的分隔符。
    //cin.getline(charArray, size);
    //从 `cin` 读取最多 `size-1` 个字符到字符数组 `charArray` 中，保留最后一个位置给结束符 `\0`。
    ```
   
   * 字符数组示例：

    ```cpp
    #include <iostream>
    const int SIZE = 100;
    int main() {
        char str[SIZE];
        std::cout << "请输入一行文本：";
        std::cin.getline(str, SIZE);
        std::cout << "你输入的是：" << str << std::endl;
        return 0;
    }
    ```
   * 注意事项：
   
   > 当使用 `getline` 读取 `std::cin` 时，如果之前有使用 `>>` 操作符读取数据，且用户输入了额外的空格或换行符，这些额外的字符会被留在缓冲区中，可能会影响后续的 `getline` 调用。在这种情况下，可以先调用 `cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');` 来清除缓冲区。
   
   > `getline` 会读取分隔符之前的所有字符，但不包括分隔符本身。如果分隔符是最后一个读入的字符，它会被留在输入流中。
   
   > 使用字符数组时，确保数组足够大，以避免溢出。使用 `std::string` 更安全，因为它会自动管理内存。
   
   > `getline`与`std::cin`一起使用时，是用于读取`std::string`类型的，而不是读取字符数组的。


3. **ignore()**

   - 忽略输入流中的指定数量字符或直到遇到特定字符为止。

     ```cpp
     cin.ignore(numeric_limits<streamsize>::max(), '\n'); // 忽略当前行剩下的所有字符
     //也能清除`cin`中的换行符，这可以防止在连续调用`cin >>`时出现问题，避免对后续输入产生影响
     //使用 `cin` 时，记得处理可能出现的错误情况，如无效输入，以确保程序的健壮性。
     ```

4. **peek()**

   - 查看输入流中的下一个字符但不提取它。

     ```cpp
     if (cin.peek() == '\n') { /* 下一个字符是换行 */ }
     ```

5. **eof()**

   - 检查是否到达输入流的结束。

     ```cpp
     if (cin.eof()) { /* 已经到达文件尾 */ }
     ```

6. **good(), bad(), fail(), eof()**

   - 这些函数用于检查 `cin` 的状态，判断是否发生了错误或是否到达文件尾。
     - `good()`：如果流没有错误，返回 true。
     - `bad()`：如果发生不可恢复的错误，返回 true。
     - `fail()`：如果发生读取或格式错误，返回 true。
     - `eof()`：如果上次读取操作到达文件尾，返回 true。

7. **ws()**

   - 用于跳过输入流中的空白字符，直到遇到非空白字符。通常用于 `>>` 操作之前，以忽略不需要的空白。

     ```cpp
     cin >> ws; // 跳过空白字符
     ```

8. **width() 和 precision()**

   - 控制读取或输出的宽度和精度，主要用于格式化输出，但也可影响输入时的行为。

9. **tie() 和 untie()**

   - 控制与关联的输出流（通常是 `cout`）的同步。`untie()` 可以取消同步，但通常不推荐用于 `cin`。

### 17.4 文件输入和输出
### 17.5 内核格式化

## 第十八章 探讨C++新标准
### 18.1 复习前面介绍过的C++11功能
### 18.2 移动语义和右值引用
### 18.3 新的类功能
### 18.4 Lambda函数
### 18.5 包装器
### 18.6 可变参数模板
### 18.7 C++11新增的其他功能
### 18.8 语言变化
### 18.9 接下了的任务

## 附录A 计数系统
### A.1 十进制数
### A.2 八进制数
### A.3 十六进制数
### A.4 二进制数
### A.5 二进制和十六进制

## 附录B C++保留字
### B.1 C++关键字
### B.2 替代标记
### B.3 C++库保留名称
### B.4 有特殊含义的标识符

## 附录C ASCII字符集

## 附录D 运算符优先级

## 附录E 其他运算符
### E.1 按位运算符
### E.2 成员解除引用运算符
### E.3 alignof（C++11）
### E.3 noexcept（C++11）

## 附录F 模板类string
### F.1 13种类型和一个常量
### F.2 数据信息、构造函数及其他
### F.3 字符串存取

### F.4 基本赋值
### F.5 字符串搜索
### F.6 比较方法和函数
### F.7 字符串修改方法
### F.8 输出和输入

## 附录G 标准模板库方法和函数
### G.1 STL和C++11
### G.2 大部分容器都有的成员
### G.3 序列容器的其他成员
### G.4 set和map的其他操作
### G.5 无序关联容器（C++11）
### G.6 STL函数

## 附录H 精选读物和网上资源
### H.1 精选读物
### H.2 网上资源

## 附录I 转换为ISO标准C++
### I.1 使用一些预处理器编译指令的替代品
### I.2 使用函数原型
### I.3 使用类型转换
### I.4 熟悉C++特性
### I.5 使用新的头文件
### I.6 使用名称空间
### I.7 使用智能指针
### I.8 使用string类
### I.9 使用STL
